{"version":3,"file":"610.js","sources":["../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/utils.mjs","../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/common.mjs","../node_modules/.pnpm/graphql-ws@5.8.2_graphql@15.5.1/node_modules/graphql-ws/lib/client.mjs","../altair-core/src/request/handlers/graphql-ws.ts"],"sourceRoot":"webpack:///","sourcesContent":["// Extremely small optimisation, reduces runtime prototype traversal\nconst baseHasOwnProperty = Object.prototype.hasOwnProperty;\n/** @private */\nexport function isObject(val) {\n    return typeof val === 'object' && val !== null;\n}\n/** @private */\nexport function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/** @private */\nexport function isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function'\n    // for lazy ones, we only need the return anyway\n    // typeof val.throw === 'function' &&\n    // typeof val.next === 'function'\n    );\n}\n/** @private */\nexport function areGraphQLErrors(obj) {\n    return (Array.isArray(obj) &&\n        // must be at least one error\n        obj.length > 0 &&\n        // error has at least a message\n        obj.every((ob) => 'message' in ob));\n}\n/** @private */\nexport function hasOwnProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop);\n}\n/** @private */\nexport function hasOwnObjectProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && isObject(obj[prop]);\n}\n/** @private */\nexport function hasOwnArrayProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && Array.isArray(obj[prop]);\n}\n/** @private */\nexport function hasOwnStringProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === 'string';\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */\nexport function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n","/**\n *\n * common\n *\n */\nimport { isObject, areGraphQLErrors, hasOwnProperty, hasOwnObjectProperty, hasOwnStringProperty, } from './utils.mjs';\n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */\nexport const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n *\n * @category Common\n */\nexport var CloseCode;\n(function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */\nexport var MessageType;\n(function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Checks if the provided value is a message.\n *\n * @category Common\n */\nexport function isMessage(val) {\n    if (isObject(val)) {\n        // all messages must have the `type` prop\n        if (!hasOwnStringProperty(val, 'type')) {\n            return false;\n        }\n        // validate other properties depending on the `type`\n        switch (val.type) {\n            case MessageType.ConnectionInit:\n                // the connection init message can have optional payload object\n                return (!hasOwnProperty(val, 'payload') ||\n                    val.payload === undefined ||\n                    isObject(val.payload));\n            case MessageType.ConnectionAck:\n            case MessageType.Ping:\n            case MessageType.Pong:\n                // the connection ack, ping and pong messages can have optional payload object too\n                return (!hasOwnProperty(val, 'payload') ||\n                    val.payload === undefined ||\n                    isObject(val.payload));\n            case MessageType.Subscribe:\n                return (hasOwnStringProperty(val, 'id') &&\n                    hasOwnObjectProperty(val, 'payload') &&\n                    (!hasOwnProperty(val.payload, 'operationName') ||\n                        val.payload.operationName === undefined ||\n                        val.payload.operationName === null ||\n                        typeof val.payload.operationName === 'string') &&\n                    hasOwnStringProperty(val.payload, 'query') &&\n                    (!hasOwnProperty(val.payload, 'variables') ||\n                        val.payload.variables === undefined ||\n                        val.payload.variables === null ||\n                        hasOwnObjectProperty(val.payload, 'variables')) &&\n                    (!hasOwnProperty(val.payload, 'extensions') ||\n                        val.payload.extensions === undefined ||\n                        val.payload.extensions === null ||\n                        hasOwnObjectProperty(val.payload, 'extensions')));\n            case MessageType.Next:\n                return (hasOwnStringProperty(val, 'id') &&\n                    hasOwnObjectProperty(val, 'payload'));\n            case MessageType.Error:\n                return hasOwnStringProperty(val, 'id') && areGraphQLErrors(val.payload);\n            case MessageType.Complete:\n                return hasOwnStringProperty(val, 'id');\n            default:\n                return false;\n        }\n    }\n    return false;\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */\nexport function parseMessage(data, reviver) {\n    if (isMessage(data)) {\n        return data;\n    }\n    if (typeof data !== 'string') {\n        throw new Error('Message not parsable');\n    }\n    const message = JSON.parse(data, reviver);\n    if (!isMessage(message)) {\n        throw new Error('Invalid message');\n    }\n    return message;\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */\nexport function stringifyMessage(msg, replacer) {\n    if (!isMessage(msg)) {\n        throw new Error('Cannot stringify invalid message');\n    }\n    return JSON.stringify(msg, replacer);\n}\n","/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete. but only if no lock got created in the meantime and\n                            // if the socket is still open\n                            setTimeout(() => {\n                                if (!locks && socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeout);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID();\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case MessageType.Next: {\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send(stringifyMessage({\n                            id,\n                            type: MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                    id,\n                                    type: MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n","import { Observable, Subscriber } from 'rxjs';\nimport {\n  GraphQLRequestHandler,\n  GraphQLRequestOptions,\n  GraphQLResponseData,\n} from '../types';\nimport { Client, createClient } from 'graphql-ws';\nimport { simpleResponseObserver } from '../utils';\n\nexport class GraphQLWsRequestHandler implements GraphQLRequestHandler {\n  client?: Client;\n  cleanup?: () => void;\n\n  handle(request: GraphQLRequestOptions): Observable<GraphQLResponseData> {\n    return new Observable((subscriber) => {\n      this.client = createClient({\n        url: request.url,\n        connectionParams: request.additionalParams,\n        lazy: false,\n        onNonLazyError: (err) => {\n          subscriber.error(err);\n        },\n        on: {\n          error: (err) => {\n            subscriber.error(err);\n          },\n        },\n      });\n\n      if (!this.client) {\n        throw new Error('Could not create GraphQL WS client!');\n      }\n\n      const requestStartTimestamp = Date.now();\n\n      this.cleanup = this.client.subscribe(\n        {\n          query: request.query,\n          variables: request.variables,\n          operationName: request.selectedOperation ?? undefined,\n          extensions: request.extensions,\n        },\n        simpleResponseObserver(subscriber, request.url, requestStartTimestamp)\n      );\n\n      return () => {\n        this.destroy();\n      };\n    });\n  }\n\n  async destroy() {\n    try {\n      this.cleanup?.();\n      this.cleanup = undefined;\n      // This causes the 'Error: Uncaught (in promise): Event: {\"isTrusted\":true}' error\n      await this.client?.dispose();\n      this.client = undefined;\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n  }\n}\n"],"names":["baseHasOwnProperty","Object","prototype","hasOwnProperty","isObject","val","obj","prop","call","hasOwnObjectProperty","hasOwnStringProperty","limitCloseReason","reason","whenTooLong","length","CloseCode","InternalServerError","InternalClientError","BadRequest","BadResponse","Unauthorized","Forbidden","SubprotocolNotAcceptable","ConnectionInitialisationTimeout","ConnectionAcknowledgementTimeout","SubscriberAlreadyExists","TooManyInitialisationRequests","MessageType","ConnectionInit","ConnectionAck","Ping","Pong","Subscribe","Next","Error","Complete","isMessage","type","undefined","payload","operationName","variables","extensions","areGraphQLErrors","Array","isArray","every","ob","stringifyMessage","msg","replacer","JSON","stringify","isLikeCloseEvent","GraphQLWsRequestHandler","handle","request","Observable","subscriber","this","client","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","_randomisedExponentialBackoff","_asyncToGenerator","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","randomisedExponentialBackoff","_x","apply","arguments","shouldRetry","isFatalConnectionProblem","on","webSocketImpl","generateID","replace","c","r","toString","jsonMessageReplacer","jsonMessageReviver","reviver","ws","isWebSocket","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","id","listener","emit","_a","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","_connect","socket","throwOnClose","denied","code","connectionAckTimeout","queuedPing","enqueuePing","isFinite","clearTimeout","readyState","OPEN","send","errOrEvent","close","onerror","onclose","onopen","acknowledged","onmessage","data","parseMessage","parse","_","reject","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","next","finally","catch","dispose","terminate","wasClean","additionalParams","requestStartTimestamp","Date","now","cleanup","query","selectedOperation","simpleResponseObserver","destroy","_this"],"mappings":"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","debug_id":"a3f27350-700f-5008-a938-cc3824e46f85"}