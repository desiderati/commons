{"version":3,"file":"82.js","sources":["./src/app/modules/altair/components/doc-viewer/doc-utils.ts"],"sourceRoot":"webpack:///","sourcesContent":["import Fuse from 'fuse.js';\nimport { GraphQLSchema } from 'graphql/type/schema';\nimport { DocumentIndexEntry, DocumentIndexFieldEntry } from './models';\nimport { buildSchema } from 'graphql/utilities';\nimport getRootTypes from '../../utils/get-root-types';\nimport { GraphQLObjectType, GraphQLFieldMap, GraphQLType } from 'graphql';\nimport { generateQuery } from '../../services/gql/generateQuery';\n\nexport class DocUtils {\n  schema?: GraphQLSchema;\n  searchIndex: DocumentIndexEntry[] = [];\n\n  constructor(sdl?: string) {\n    if (sdl) {\n      this.updateSchema(sdl);\n    }\n  }\n\n  updateSchema(sdl: string) {\n    this.schema = buildSchema(sdl);\n  }\n\n  /**\n   * Generate the search index from the schema\n   * @param schema\n   */\n  generateSearchIndex() {\n    if (!this.schema) {\n      return [];\n    }\n\n    let searchIndex: DocumentIndexEntry[] = [];\n\n    const rootTypes = getRootTypes(this.schema);\n\n    // Store the indices of all the types and fields\n    rootTypes.forEach((type) => {\n      searchIndex = [\n        ...searchIndex,\n        ...this.getTypeIndices(type, true, searchIndex),\n      ];\n    });\n\n    // Get types from typeMap into index as well, excluding the __\n    const schemaTypeMap = this.schema.getTypeMap();\n    Object.keys(schemaTypeMap).forEach((key) => {\n      if (!/^__/.test(key)) {\n        searchIndex = [\n          ...searchIndex,\n          ...this.getTypeIndices(\n            schemaTypeMap[key] as GraphQLObjectType,\n            false,\n            searchIndex\n          ),\n        ];\n      }\n    });\n\n    this.searchIndex = searchIndex;\n    return searchIndex;\n  }\n\n  /**\n   * Gets the indices for fields\n   */\n  getFieldsIndices(\n    fields: GraphQLFieldMap<any, any>,\n    type: GraphQLType,\n    isQuery: boolean,\n    curIndexStack: DocumentIndexEntry[]\n  ): DocumentIndexEntry[] {\n    let index: DocumentIndexEntry[] = [];\n\n    Object.entries(fields).forEach(([fieldKey, field]) => {\n      // For each field, create an entry in the index\n      const fieldIndex: DocumentIndexFieldEntry = {\n        search: field.name,\n        name: field.name,\n        description: field.description ? field.description : '',\n        // We cannot use the GraphQLArgument objects directly since\n        //  those can't be cloned using the structured cloning algorithm when\n        // sent to the worker. So we just use the required fields\n        args: field.args?.map((arg) => ({\n          name: arg.name,\n          description: arg.description ?? '',\n        })),\n        cat: 'field',\n        type: (type as GraphQLObjectType).name,\n        isQuery,\n        highlight: 'field',\n      };\n      index = [...index, fieldIndex];\n\n      // For each argument of the field, create an entry in the index for the field,\n      // searchable by the argument name\n      if (field.args && field.args.length) {\n        field.args.forEach((arg) => {\n          index = [\n            ...index,\n            {\n              ...fieldIndex,\n              search: arg.name,\n              highlight: 'argument',\n            },\n          ];\n        });\n      }\n\n      // If the field has a type, get indices for the type as well\n      if (field.type) {\n        index = [\n          ...index,\n          ...this.getTypeIndices(field.type as GraphQLObjectType, false, [\n            ...curIndexStack,\n            ...index,\n          ]).filter((val) => !!val),\n        ];\n      }\n    });\n\n    return index;\n  }\n\n  /**\n   * Gets the indices for types\n   * @param  {object} type the type object\n   * @param  {boolean} isRoot specifies if the type is a root level type\n   * @param  {array} curIndexStack contains all the currently mapped indices in the stack\n   * @return {array}            the indices for the given type\n   */\n  getTypeIndices(\n    type: GraphQLObjectType,\n    isRoot: boolean,\n    curIndexStack: DocumentIndexEntry[]\n  ): DocumentIndexEntry[] {\n    let fields: GraphQLFieldMap<any, any> | undefined;\n\n    // If a type does not have a name, don't process it\n    if (!(type as GraphQLObjectType).name) {\n      return [];\n    }\n\n    // If any type is already in the index, then don't process the type again\n    if (curIndexStack.some((x) => x.name === type.name && x.cat === 'type')) {\n      return [];\n    }\n\n    if (type.getFields) {\n      fields = type.getFields();\n    }\n\n    const _index: DocumentIndexEntry[] = [\n      {\n        search: type.name,\n        name: type.name,\n        cat: 'type',\n        description: type.description ? type.description : '',\n        isRoot,\n        highlight: 'type',\n      },\n    ];\n\n    if (fields) {\n      return [\n        ..._index,\n        ...this.getFieldsIndices(fields, type, isRoot, [\n          ...curIndexStack,\n          ..._index,\n        ]).filter((val) => !!val),\n      ];\n    }\n\n    return _index;\n  }\n\n  /**\n   * search through the docs for the provided term\n   */\n  searchDocs(term: string): DocumentIndexEntry[] {\n    if (!this.searchIndex.length) {\n      return [];\n    }\n    const fuse = new Fuse(this.searchIndex, {\n      keys: ['search'],\n      threshold: 0.4,\n    });\n\n    return fuse.search(term).map((res) => res.item);\n\n    // return this.searchIndex.filter(item => new RegExp(term as string, 'i').test(item.search));\n  }\n\n  /**\n   * Generate the query for the specified field\n   * @param field name of the current field\n   * @param parentType parent type of the current field\n   * @param parentFields preceding parent field and type combinations\n   */\n  async generateQueryV2(\n    field: string,\n    parentType: string,\n    opts: { tabSize: number; addQueryDepthLimit: number }\n  ) {\n    if (!this.schema) {\n      return;\n    }\n    const res = await generateQuery(this.schema, field, parentType, {\n      maxDepth: opts.addQueryDepthLimit,\n      tabSize: opts.tabSize,\n    });\n\n    return {\n      query: res.generated,\n      meta: res.metas.find((_) => _.hasArgs) || {},\n    };\n  }\n\n  /**\n   * Cleans out getType() names to contain only the type name itself\n   * @param name\n   */\n  cleanName(name: string) {\n    return name.replace(/[[\\]!]/g, '');\n  }\n}\n"],"names":["DocUtils","constructor","sdl","this","searchIndex","updateSchema","schema","buildSchema","generateSearchIndex","rootTypes","getRootTypes","forEach","type","getTypeIndices","schemaTypeMap","getTypeMap","Object","keys","key","test","getFieldsIndices","fields","isQuery","curIndexStack","index","entries","fieldKey","field","fieldIndex","search","name","description","args","map","arg","cat","highlight","length","filter","val","isRoot","some","x","getFields","_index","searchDocs","term","Fuse","threshold","res","item","generateQueryV2","parentType","opts","_this","_asyncToGenerator","generateQuery","maxDepth","addQueryDepthLimit","tabSize","query","generated","meta","metas","find","_","hasArgs","cleanName","replace"],"mappings":";;4KAQM,MAAOA,EAIXC,YAAYC,GAFZC,KAAAC,YAAoC,GAG9BF,GACFC,KAAKE,aAAaH,EAEtB,CAEAG,aAAaH,GACXC,KAAKG,UAASC,KAAYL,EAC5B,CAMAM,sBACE,IAAKL,KAAKG,OACR,MAAO,GAGT,IAAIF,EAAoC,IAKxCK,EAHkBC,KAAaP,KAAKG,QAG1BK,QAASC,IACjBR,EAAc,IACTA,KACAD,KAAKU,eAAeD,GAAM,EAAMR,GAAY,GAKnD,MAAMU,EAAgBX,KAAKG,OAAOS,aAClCC,cAAOC,KAAKH,GAAeH,QAASO,IAC7B,MAAMC,KAAKD,KACdd,EAAc,IACTA,KACAD,KAAKU,eACNC,EAAcI,IACd,EACAd,IACD,GAKPD,KAAKC,YAAcA,EACZA,CACT,CAKAgB,iBACEC,EACAT,EACAU,EACAC,GAEA,IAAIC,EAA8B,GAElCR,cAAOS,QAAQJ,GAAQV,QAAQ,EAAEe,EAAUC,MAEzC,MAAMC,EAAsC,CAC1CC,OAAQF,EAAMG,KACdA,KAAMH,EAAMG,KACZC,YAAaJ,EAAMI,YAAcJ,EAAMI,YAAc,GAIrDC,KAAML,EAAMK,MAAMC,IAAKC,KACrBJ,KAAMI,EAAIJ,KACVC,YAAaG,EAAIH,aAAe,MAElCI,IAAK,QACLvB,KAAOA,EAA2BkB,KAClCR,UACAc,UAAW,SAEbZ,EAAQ,IAAIA,EAAOI,GAIfD,EAAMK,MAAQL,EAAMK,KAAKK,QAC3BV,EAAMK,KAAKrB,QAASuB,IAClBV,EAAQ,IACHA,EACH,IACKI,EACHC,OAAQK,EAAIJ,KACZM,UAAW,YACZ,GAMHT,EAAMf,OACRY,EAAQ,IACHA,KACArB,KAAKU,eAAec,EAAMf,MAA2B,EAAO,IAC1DW,KACAC,IACFc,OAAQC,KAAUA,IAAI,GAKxBf,CACT,CASAX,eACED,EACA4B,EACAjB,GAEA,IAAIF,EAGJ,IAAMT,EAA2BkB,KAC/B,MAAO,GAIT,GAAIP,EAAckB,KAAMC,GAAMA,EAAEZ,OAASlB,EAAKkB,MAAkB,SAAVY,EAAEP,KACtD,MAAO,GAGLvB,EAAK+B,YACPtB,EAAST,EAAK+B,aAGhB,MAAMC,EAA+B,CACnC,CACEf,OAAQjB,EAAKkB,KACbA,KAAMlB,EAAKkB,KACXK,IAAK,OACLJ,YAAanB,EAAKmB,YAAcnB,EAAKmB,YAAc,GACnDS,SACAJ,UAAW,SAIf,OAAIf,EACK,IACFuB,KACAzC,KAAKiB,iBAAiBC,EAAQT,EAAM4B,EAAQ,IAC1CjB,KACAqB,IACFN,OAAQC,KAAUA,IAIlBK,CACT,CAKAC,WAAWC,GACT,OAAK3C,KAAKC,YAAYiC,OAGT,IAAIU,IAAK5C,KAAKC,YAAa,CACtCa,KAAM,CAAC,UACP+B,UAAW,KAGDnB,OAAOiB,GAAMb,IAAKgB,GAAQA,EAAIC,MAPjC,EAUX,CAQMC,gBACJxB,EACAyB,EACAC,GAAqD,IAAAC,EAAAnD,KAAA,SAAAoD,KAAA,YAErD,IAAKD,EAAKhD,OACR,OAEF,MAAM2C,QAAG,EAASO,MAAcF,EAAKhD,OAAQqB,EAAOyB,EAAY,CAC9DK,SAAUJ,EAAKK,mBACfC,QAASN,EAAKM,UAGhB,MAAO,CACLC,MAAOX,EAAIY,UACXC,KAAMb,EAAIc,MAAMC,KAAMC,GAAMA,EAAEC,UAAY,GAC1C,EAbmD,EAcvD,CAMAC,UAAUrC,GACR,OAAOA,EAAKsC,QAAQ,UAAW,GACjC","debug_id":"03365145-d318-55a6-a619-1d122adbad2a"}