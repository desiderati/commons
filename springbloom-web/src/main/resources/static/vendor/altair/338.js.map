{"version":3,"file":"338.js","sources":["../../node_modules/.pnpm/@babel+runtime@7.25.0/node_modules/@babel/runtime/helpers/esm/asyncIterator.js","../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/common.mjs","../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/parser.mjs","../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/client.mjs","../node_modules/.pnpm/graphql-sse@2.5.3_graphql@15.5.1/node_modules/graphql-sse/lib/utils.mjs","../altair-core/src/request/handlers/sse.ts"],"sourceRoot":"webpack:///","sourcesContent":["function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nexport { _asyncIterator as default };","/**\n *\n * common\n *\n */\nimport { isObject } from './utils.mjs';\n/**\n * Header key through which the event stream token is transmitted\n * when using the client in \"single connection mode\".\n *\n * Read more: https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md#single-connection-mode\n *\n * @category Common\n */\nexport const TOKEN_HEADER_KEY = 'x-graphql-event-stream-token';\n/**\n * URL query parameter key through which the event stream token is transmitted\n * when using the client in \"single connection mode\".\n *\n * Read more: https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md#single-connection-mode\n *\n * @category Common\n */\nexport const TOKEN_QUERY_KEY = 'token';\n/** @category Common */\nexport function validateStreamEvent(e) {\n    e = e;\n    if (e !== 'next' && e !== 'complete')\n        throw new Error(`Invalid stream event \"${e}\"`);\n    return e;\n}\n/** @category Common */\nexport function print(msg) {\n    let str = `event: ${msg.event}\\ndata:`;\n    if (msg.data) {\n        str += ' ';\n        str += JSON.stringify(msg.data);\n    }\n    str += '\\n\\n';\n    return str;\n}\n/** @category Common */\nexport function parseStreamData(e, data) {\n    if (data) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch {\n            throw new Error('Invalid stream data');\n        }\n    }\n    if (e === 'next' && !data)\n        throw new Error('Stream data must be an object for \"next\" events');\n    return (data || null);\n}\n/**\n * Checkes whether the provided value is an async iterable.\n *\n * @category Common\n */\nexport function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === 'function';\n}\n/**\n * Checkes whether the provided value is an async generator.\n *\n * @category Common\n */\nexport function isAsyncGenerator(val) {\n    return (isObject(val) &&\n        typeof Object(val)[Symbol.asyncIterator] === 'function' &&\n        typeof val.return === 'function' &&\n        typeof val.throw === 'function' &&\n        typeof val.next === 'function');\n}\n","/**\n *\n * parser\n *\n */\nimport { validateStreamEvent, parseStreamData, } from './common.mjs';\nvar ControlChars;\n(function (ControlChars) {\n    ControlChars[ControlChars[\"NewLine\"] = 10] = \"NewLine\";\n    ControlChars[ControlChars[\"CchunkiageReturn\"] = 13] = \"CchunkiageReturn\";\n    ControlChars[ControlChars[\"Space\"] = 32] = \"Space\";\n    ControlChars[ControlChars[\"Colon\"] = 58] = \"Colon\";\n})(ControlChars || (ControlChars = {}));\n/**\n * HTTP response chunk parser for graphql-sse's event stream messages.\n *\n * Reference: https://github.com/Azure/fetch-event-source/blob/main/src/parse.ts\n *\n * @private\n */\nexport function createParser() {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    let message = { event: '', data: '' };\n    let pending = [];\n    const decoder = new TextDecoder();\n    return function parse(chunk) {\n        if (buffer === undefined) {\n            buffer = chunk;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            const concat = new Uint8Array(buffer.length + chunk.length);\n            concat.set(buffer);\n            concat.set(chunk, buffer.length);\n            buffer = concat;\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === ControlChars.NewLine) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // look forward until the end of line\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case ControlChars.Colon:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // \\r case below should fallthrough to \\n:\n                    case ControlChars.CchunkiageReturn:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case ControlChars.NewLine:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // end of the buffer but the line hasn't ended\n                break;\n            }\n            else if (lineStart === lineEnd) {\n                // empty line denotes end of incoming message\n                if (message.event || message.data) {\n                    // NOT a server ping (\":\\n\\n\")\n                    if (!message.event)\n                        throw new Error('Missing message event');\n                    const event = validateStreamEvent(message.event);\n                    const data = parseStreamData(event, message.data);\n                    pending.push({\n                        event,\n                        data,\n                    });\n                    message = { event: '', data: '' };\n                }\n            }\n            else if (fieldLength > 0) {\n                // end of line indicates message\n                const line = buffer.subarray(lineStart, lineEnd);\n                // exclude comments and lines with no values\n                // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n                // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n                const field = decoder.decode(line.subarray(0, fieldLength));\n                const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n                const value = decoder.decode(line.subarray(valueOffset));\n                switch (field) {\n                    case 'event':\n                        message.event = value;\n                        break;\n                    case 'data':\n                        // append the new value if the message has data\n                        message.data = message.data ? message.data + '\\n' + value : value;\n                        break;\n                }\n            }\n            // next line\n            lineStart = position;\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            // finished reading\n            buffer = undefined;\n            const messages = [...pending];\n            pending = [];\n            return messages;\n        }\n        else if (lineStart !== 0) {\n            // create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new chunk\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n","/**\n *\n * client\n *\n */\nimport { createParser } from './parser.mjs';\nimport { isObject } from './utils.mjs';\nimport { TOKEN_HEADER_KEY, } from './common.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over SSE client to transmit\n * GraphQL operation results.\n *\n * If you have an HTTP/2 server, it is recommended to use the client\n * in \"distinct connections mode\" (`singleConnection = false`) which will\n * create a new SSE connection for each subscribe. This is the default.\n *\n * However, when dealing with HTTP/1 servers from a browser, consider using\n * the \"single connection mode\" (`singleConnection = true`) which will\n * use only one SSE connection.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { singleConnection = false, lazy = true, lazyCloseTimeout = 0, onNonLazyError = console.error, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, retryAttempts = 5, retry = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, credentials = 'same-origin', referrer, referrerPolicy, onMessage, on: clientOn, } = options;\n    const fetchFn = (options.fetchFn || fetch);\n    const AbortControllerImpl = (options.abortControllerImpl ||\n        AbortController);\n    // we dont use yet another AbortController here because of\n    // node's max EventEmitters listeners being only 10\n    const client = (() => {\n        let disposed = false;\n        const listeners = [];\n        return {\n            get disposed() {\n                return disposed;\n            },\n            onDispose(cb) {\n                if (disposed) {\n                    // empty the call stack and then call the cb\n                    setTimeout(() => cb(), 0);\n                    return () => {\n                        // noop\n                    };\n                }\n                listeners.push(cb);\n                return () => {\n                    listeners.splice(listeners.indexOf(cb), 1);\n                };\n            },\n            dispose() {\n                if (disposed)\n                    return;\n                disposed = true;\n                // we copy the listeners so that onDispose unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners]) {\n                    listener();\n                }\n            },\n        };\n    })();\n    let connCtrl, conn, locks = 0, retryingErr = null, retries = 0;\n    async function getOrConnect() {\n        try {\n            if (client.disposed)\n                throw new Error('Client has been disposed');\n            return await (conn !== null && conn !== void 0 ? conn : (conn = (async () => {\n                var _a, _b, _c;\n                if (retryingErr) {\n                    await retry(retries);\n                    // connection might've been aborted while waiting for retry\n                    if (connCtrl.signal.aborted)\n                        throw new Error('Connection aborted by the client');\n                    retries++;\n                }\n                (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);\n                // we must create a new controller here because lazy mode aborts currently active ones\n                connCtrl = new AbortControllerImpl();\n                const unlistenDispose = client.onDispose(() => connCtrl.abort());\n                connCtrl.signal.addEventListener('abort', () => {\n                    unlistenDispose();\n                    conn = undefined;\n                });\n                const url = typeof options.url === 'function'\n                    ? await options.url()\n                    : options.url;\n                if (connCtrl.signal.aborted)\n                    throw new Error('Connection aborted by the client');\n                const headers = typeof options.headers === 'function'\n                    ? await options.headers()\n                    : (_b = options.headers) !== null && _b !== void 0 ? _b : {};\n                if (connCtrl.signal.aborted)\n                    throw new Error('Connection aborted by the client');\n                let res;\n                try {\n                    res = await fetchFn(url, {\n                        signal: connCtrl.signal,\n                        method: 'PUT',\n                        credentials,\n                        referrer,\n                        referrerPolicy,\n                        headers,\n                    });\n                }\n                catch (err) {\n                    throw new NetworkError(err);\n                }\n                if (res.status !== 201)\n                    throw new NetworkError(res);\n                const token = await res.text();\n                headers[TOKEN_HEADER_KEY] = token;\n                const connected = await connect({\n                    signal: connCtrl.signal,\n                    headers,\n                    credentials,\n                    referrer,\n                    referrerPolicy,\n                    url,\n                    fetchFn,\n                    onMessage: (msg) => {\n                        var _a;\n                        (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a === void 0 ? void 0 : _a.call(clientOn, msg);\n                        onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg); // @deprecated\n                    },\n                });\n                (_c = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _c === void 0 ? void 0 : _c.call(clientOn, !!retryingErr);\n                connected.waitForThrow().catch(() => (conn = undefined));\n                return connected;\n            })()));\n        }\n        catch (err) {\n            // whatever problem happens during connect means the connection was not established\n            conn = undefined;\n            throw err;\n        }\n    }\n    // non-lazy mode always holds one lock to persist the connection\n    if (singleConnection && !lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const { waitForThrow } = await getOrConnect();\n                    await waitForThrow();\n                }\n                catch (err) {\n                    if (client.disposed)\n                        return;\n                    // all non-network errors are worth reporting immediately\n                    if (!(err instanceof NetworkError))\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n                    // was a network error, get rid of the current connection to ensure retries\n                    conn = undefined;\n                    // retries are not allowed or we tried to many times, report error\n                    if (!retryAttempts || retries >= retryAttempts)\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n                    // try again\n                    retryingErr = err;\n                }\n            }\n        })();\n    }\n    function subscribe(request, sink, on) {\n        if (!singleConnection) {\n            // distinct connections mode\n            const control = new AbortControllerImpl();\n            const unlisten = client.onDispose(() => {\n                unlisten();\n                control.abort();\n            });\n            (async () => {\n                var _a, _b, _c, _d, _e;\n                let retryingErr = null, retries = 0;\n                for (;;) {\n                    try {\n                        if (retryingErr) {\n                            await retry(retries);\n                            // connection might've been aborted while waiting for retry\n                            if (control.signal.aborted)\n                                throw new Error('Connection aborted by the client');\n                            retries++;\n                        }\n                        (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connecting) === null || _a === void 0 ? void 0 : _a.call(clientOn, !!retryingErr);\n                        (_b = on === null || on === void 0 ? void 0 : on.connecting) === null || _b === void 0 ? void 0 : _b.call(on, !!retryingErr);\n                        const url = typeof options.url === 'function'\n                            ? await options.url()\n                            : options.url;\n                        if (control.signal.aborted)\n                            throw new Error('Connection aborted by the client');\n                        const headers = typeof options.headers === 'function'\n                            ? await options.headers()\n                            : (_c = options.headers) !== null && _c !== void 0 ? _c : {};\n                        if (control.signal.aborted)\n                            throw new Error('Connection aborted by the client');\n                        const { getResults } = await connect({\n                            signal: control.signal,\n                            headers: {\n                                ...headers,\n                                'content-type': 'application/json; charset=utf-8',\n                            },\n                            credentials,\n                            referrer,\n                            referrerPolicy,\n                            url,\n                            body: JSON.stringify(request),\n                            fetchFn,\n                            onMessage: (msg) => {\n                                var _a, _b;\n                                (_a = clientOn === null || clientOn === void 0 ? void 0 : clientOn.message) === null || _a === void 0 ? void 0 : _a.call(clientOn, msg);\n                                (_b = on === null || on === void 0 ? void 0 : on.message) === null || _b === void 0 ? void 0 : _b.call(on, msg);\n                                onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg); // @deprecated\n                            },\n                        });\n                        (_d = clientOn === null || clientOn === void 0 ? void 0 : clientOn.connected) === null || _d === void 0 ? void 0 : _d.call(clientOn, !!retryingErr);\n                        (_e = on === null || on === void 0 ? void 0 : on.connected) === null || _e === void 0 ? void 0 : _e.call(on, !!retryingErr);\n                        for await (const result of getResults()) {\n                            // only after receiving results are future connects not considered retries.\n                            // this is because a client might successfully connect, but the server\n                            // ends up terminating the connection afterwards before streaming anything.\n                            // of course, if the client completes the subscription, this loop will\n                            // break and therefore stop the stream (it wont reconnect)\n                            retryingErr = null;\n                            retries = 0;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            sink.next(result);\n                        }\n                        return control.abort();\n                    }\n                    catch (err) {\n                        if (control.signal.aborted)\n                            return;\n                        // all non-network errors are worth reporting immediately\n                        if (!(err instanceof NetworkError))\n                            throw err;\n                        // retries are not allowed or we tried to many times, report error\n                        if (!retryAttempts || retries >= retryAttempts)\n                            throw err;\n                        // try again\n                        retryingErr = err;\n                    }\n                }\n            })()\n                .then(() => sink.complete())\n                .catch((err) => sink.error(err));\n            return () => control.abort();\n        }\n        // single connection mode\n        locks++;\n        const control = new AbortControllerImpl();\n        const unlisten = client.onDispose(() => {\n            unlisten();\n            control.abort();\n        });\n        (async () => {\n            const operationId = generateID();\n            request = {\n                ...request,\n                extensions: { ...request.extensions, operationId },\n            };\n            let complete = null;\n            for (;;) {\n                complete = null;\n                try {\n                    const { url, headers, getResults } = await getOrConnect();\n                    let res;\n                    try {\n                        res = await fetchFn(url, {\n                            signal: control.signal,\n                            method: 'POST',\n                            credentials,\n                            referrer,\n                            referrerPolicy,\n                            headers: {\n                                ...headers,\n                                'content-type': 'application/json; charset=utf-8',\n                            },\n                            body: JSON.stringify(request),\n                        });\n                    }\n                    catch (err) {\n                        throw new NetworkError(err);\n                    }\n                    if (res.status !== 202)\n                        throw new NetworkError(res);\n                    complete = async () => {\n                        let res;\n                        try {\n                            const control = new AbortControllerImpl();\n                            const unlisten = client.onDispose(() => {\n                                unlisten();\n                                control.abort();\n                            });\n                            res = await fetchFn(url + '?operationId=' + operationId, {\n                                signal: control.signal,\n                                method: 'DELETE',\n                                credentials,\n                                referrer,\n                                referrerPolicy,\n                                headers,\n                            });\n                        }\n                        catch (err) {\n                            throw new NetworkError(err);\n                        }\n                        if (res.status !== 200)\n                            throw new NetworkError(res);\n                    };\n                    for await (const result of getResults({\n                        signal: control.signal,\n                        operationId,\n                    })) {\n                        // only after receiving results are future connects not considered retries.\n                        // this is because a client might successfully connect, but the server\n                        // ends up terminating the connection afterwards before streaming anything.\n                        // of course, if the client completes the subscription, this loop will\n                        // break and therefore stop the stream (it wont reconnect)\n                        retryingErr = null;\n                        retries = 0;\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        sink.next(result);\n                    }\n                    complete = null; // completed by the server\n                    return control.abort();\n                }\n                catch (err) {\n                    if (control.signal.aborted)\n                        return await (complete === null || complete === void 0 ? void 0 : complete());\n                    // all non-network errors are worth reporting immediately\n                    if (!(err instanceof NetworkError)) {\n                        control.abort(); // TODO: tests for making sure the control's aborted\n                        throw err;\n                    }\n                    // was a network error, get rid of the current connection to ensure retries\n                    // but only if the client is running in lazy mode (otherwise the non-lazy lock will get rid of the connection)\n                    if (lazy) {\n                        conn = undefined;\n                    }\n                    // retries are not allowed or we tried to many times, report error\n                    if (!retryAttempts || retries >= retryAttempts) {\n                        control.abort(); // TODO: tests for making sure the control's aborted\n                        throw err;\n                    }\n                    // try again\n                    retryingErr = err;\n                }\n                finally {\n                    // release lock if subscription is aborted\n                    if (control.signal.aborted && --locks === 0) {\n                        if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n                            // allow for the specified calmdown time and then close the\n                            // connection, only if no lock got created in the meantime and\n                            // if the connection is still open\n                            setTimeout(() => {\n                                if (!locks)\n                                    connCtrl.abort();\n                            }, lazyCloseTimeout);\n                        }\n                        else {\n                            // otherwise close immediately\n                            connCtrl.abort();\n                        }\n                    }\n                }\n            }\n        })()\n            .then(() => sink.complete())\n            .catch((err) => sink.error(err));\n        return () => control.abort();\n    }\n    return {\n        subscribe,\n        iterate(request, on) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            }, on);\n            const iterator = (async function* iterator() {\n                for (;;) {\n                    if (!pending.length) {\n                        // only wait if there are no pending messages available\n                        await new Promise((resolve) => (deferred.resolve = resolve));\n                    }\n                    // first flush\n                    while (pending.length) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        yield pending.shift();\n                    }\n                    // then error\n                    if (deferred.error) {\n                        throw deferred.error;\n                    }\n                    // or complete\n                    if (deferred.done) {\n                        return;\n                    }\n                }\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        dispose() {\n            client.dispose();\n        },\n    };\n}\n/**\n * A network error caused by the client or an unexpected response from the server.\n *\n * Network errors are considered retryable, all others error types will be reported\n * immediately.\n *\n * To avoid bundling DOM typings (because the client can run in Node env too),\n * you should supply the `Response` generic depending on your Fetch implementation.\n *\n * @category Client\n */\nexport class NetworkError extends Error {\n    constructor(msgOrErrOrResponse) {\n        let message, response;\n        if (isResponseLike(msgOrErrOrResponse)) {\n            response = msgOrErrOrResponse;\n            message =\n                'Server responded with ' +\n                    msgOrErrOrResponse.status +\n                    ': ' +\n                    msgOrErrOrResponse.statusText;\n        }\n        else if (msgOrErrOrResponse instanceof Error)\n            message = msgOrErrOrResponse.message;\n        else\n            message = String(msgOrErrOrResponse);\n        super(message);\n        this.name = this.constructor.name;\n        this.response = response;\n    }\n}\nfunction isResponseLike(val) {\n    return (isObject(val) &&\n        typeof val['ok'] === 'boolean' &&\n        typeof val['status'] === 'number' &&\n        typeof val['statusText'] === 'string');\n}\nasync function connect(options) {\n    const { signal, url, credentials, headers, body, referrer, referrerPolicy, fetchFn, onMessage, } = options;\n    const waiting = {};\n    const queue = {};\n    let res;\n    try {\n        res = await fetchFn(url, {\n            signal,\n            method: body ? 'POST' : 'GET',\n            credentials,\n            referrer,\n            referrerPolicy,\n            headers: {\n                ...headers,\n                accept: 'text/event-stream',\n            },\n            body,\n        });\n    }\n    catch (err) {\n        throw new NetworkError(err);\n    }\n    if (!res.ok)\n        throw new NetworkError(res);\n    if (!res.body)\n        throw new Error('Missing response body');\n    let error = null;\n    let waitingForThrow;\n    (async () => {\n        var _a;\n        try {\n            const parse = createParser();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            for await (const chunk of toAsyncIterator(res.body)) {\n                if (typeof chunk === 'string')\n                    throw (error = new Error(`Unexpected string chunk \"${chunk}\"`)); // set error as fatal indicator\n                // read chunk and if messages are ready, yield them\n                let msgs;\n                try {\n                    msgs = parse(chunk);\n                }\n                catch (err) {\n                    throw (error = err); // set error as fatal indicator\n                }\n                if (!msgs)\n                    continue;\n                for (const msg of msgs) {\n                    try {\n                        onMessage === null || onMessage === void 0 ? void 0 : onMessage(msg);\n                    }\n                    catch (err) {\n                        throw (error = err); // set error as fatal indicator\n                    }\n                    const operationId = msg.data && 'id' in msg.data\n                        ? msg.data.id // StreamDataForID\n                        : ''; // StreamData\n                    if (!(operationId in queue))\n                        queue[operationId] = [];\n                    switch (msg.event) {\n                        case 'next':\n                            if (operationId)\n                                queue[operationId].push(msg.data.payload);\n                            else\n                                queue[operationId].push(msg.data);\n                            break;\n                        case 'complete':\n                            queue[operationId].push('complete');\n                            break;\n                        default:\n                            throw (error = new Error(`Unexpected message event \"${msg.event}\"`)); // set error as fatal indicator\n                    }\n                    (_a = waiting[operationId]) === null || _a === void 0 ? void 0 : _a.proceed();\n                }\n            }\n            // some browsers (like Safari) closes the connection without errors even on abrupt server shutdowns,\n            // we therefore make sure that no stream is active and waiting for results (not completed)\n            if (Object.keys(waiting).length) {\n                throw new Error('Connection closed while having active streams');\n            }\n        }\n        catch (err) {\n            if (!error && Object.keys(waiting).length) {\n                // we assume the error is most likely a NetworkError because there are listeners waiting for events.\n                // additionally, the `error` is another indicator because we set it early if the error is considered fatal\n                error = new NetworkError(err);\n            }\n            else {\n                error = err;\n            }\n            waitingForThrow === null || waitingForThrow === void 0 ? void 0 : waitingForThrow(error);\n        }\n        finally {\n            Object.values(waiting).forEach(({ proceed }) => proceed());\n        }\n    })();\n    return {\n        url,\n        headers,\n        waitForThrow: () => new Promise((_, reject) => {\n            if (error)\n                return reject(error);\n            waitingForThrow = reject;\n        }),\n        async *getResults(options) {\n            var _a;\n            const { signal, operationId = '' } = options !== null && options !== void 0 ? options : {};\n            // operationId === '' ? StreamData : StreamDataForID\n            try {\n                for (;;) {\n                    while ((_a = queue[operationId]) === null || _a === void 0 ? void 0 : _a.length) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const result = queue[operationId].shift();\n                        if (result === 'complete')\n                            return;\n                        yield result;\n                    }\n                    if (error)\n                        throw error;\n                    if (signal === null || signal === void 0 ? void 0 : signal.aborted)\n                        throw new Error('Getting results aborted by the client');\n                    await new Promise((resolve) => {\n                        const proceed = () => {\n                            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', proceed);\n                            delete waiting[operationId];\n                            resolve();\n                        };\n                        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', proceed);\n                        waiting[operationId] = { proceed };\n                    });\n                }\n            }\n            finally {\n                delete queue[operationId];\n            }\n        },\n    };\n}\n/** Isomorphic ReadableStream to AsyncIterator converter. */\nfunction toAsyncIterator(val) {\n    // node stream is already async iterable\n    if (typeof Object(val)[Symbol.asyncIterator] === 'function') {\n        val = val;\n        return val[Symbol.asyncIterator]();\n    }\n    // convert web stream to async iterable\n    return (async function* () {\n        const reader = val.getReader();\n        let result;\n        do {\n            result = await reader.read();\n            if (result.value !== undefined)\n                yield result.value;\n        } while (!result.done);\n    })();\n}\n","/**\n *\n * utils\n *\n */\n/** @private */\nexport function isObject(val) {\n    return typeof val === 'object' && val !== null;\n}\n","import { Observable } from 'rxjs';\nimport {\n  GraphQLRequestHandler,\n  GraphQLRequestOptions,\n  GraphQLResponseData,\n} from '../types';\nimport { Client, createClient } from 'graphql-sse';\nimport { simpleResponseObserver } from '../utils';\n\nexport class SSERequestHandler implements GraphQLRequestHandler {\n  client?: Client;\n  cleanup?: () => void;\n\n  handle(request: GraphQLRequestOptions): Observable<GraphQLResponseData> {\n    return new Observable((subscriber) => {\n      this.client = createClient({\n        url: request.url,\n        credentials: request.withCredentials ? 'include' : 'same-origin',\n        headers: request.headers?.reduce(\n          (acc, { key, value }) => {\n            acc[key] = value;\n            return acc;\n          },\n          {} as Record<string, string>\n        ),\n      });\n\n      if (!this.client) {\n        throw new Error('Could not create SSE client!');\n      }\n      const requestStartTimestamp = Date.now();\n      this.cleanup = this.client.subscribe(\n        {\n          query: request.query,\n          variables: request.variables,\n          operationName: request.selectedOperation ?? undefined,\n          extensions: request.extensions,\n        },\n        simpleResponseObserver(subscriber, request.url, requestStartTimestamp)\n      );\n\n      return () => {\n        this.destroy();\n      };\n    });\n  }\n\n\n  async destroy() {\n    try {\n      this.cleanup?.();\n      this.cleanup = undefined;\n      await this.client?.dispose();\n      this.client = undefined;\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}\n"],"names":["_asyncIterator","r","n","t","o","e","Symbol","asyncIterator","iterator","call","AsyncFromSyncIterator","TypeError","AsyncFromSyncIteratorContinuation","Object","Promise","reject","done","resolve","value","then","this","s","next","prototype","apply","arguments","return","throw","validateStreamEvent","Error","parseStreamData","data","JSON","parse","ControlChars","NewLine","CchunkiageReturn","Space","Colon","NetworkError","constructor","msgOrErrOrResponse","message","response","isResponseLike","val","isObject","ok","status","statusText","String","super","name","connect","_x3","_connect","_asyncToGenerator","options","signal","url","credentials","headers","body","referrer","referrerPolicy","fetchFn","onMessage","waiting","queue","res","method","accept","err","waitingForThrow","error","_a","createParser","buffer","position","fieldLength","discardTrailingNewline","event","pending","decoder","TextDecoder","chunk","undefined","concat","Uint8Array","length","set","bufLength","lineStart","lineEnd","push","line","subarray","field","decode","messages","_iteratorError3","_iteratorAbruptCompletion3","_didIteratorError3","_step3","_iterator4","toAsyncIterator","_wrapAsyncGenerator","reader","getReader","result","_awaitAsyncGenerator","read","msgs","msg","operationId","id","payload","proceed","keys","values","forEach","waitForThrow","_","getResults","shift","aborted","removeEventListener","addEventListener","SSERequestHandler","handle","request","Observable","subscriber","client","createClient","singleConnection","lazy","lazyCloseTimeout","onNonLazyError","console","generateID","replace","c","Math","random","toString","retryAttempts","retry","_randomisedExponentialBackoff","retries","retryDelay","i","setTimeout","floor","randomisedExponentialBackoff","_x","on","clientOn","fetch","AbortControllerImpl","abortControllerImpl","AbortController","disposed","listeners","onDispose","cb","splice","indexOf","dispose","listener","connCtrl","conn","locks","retryingErr","getOrConnect","_getOrConnect","_b","_c","connecting","unlistenDispose","abort","token","text","connected","catch","subscribe","sink","control","unlisten","_d","_e","stringify","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_step","_iterator","complete","extensions","_ref5","_iteratorError2","_iteratorAbruptCompletion2","_didIteratorError2","_step2","_iterator2","isFinite","iterate","deferred","_iterator3","_ref6","_x2","withCredentials","reduce","acc","key","requestStartTimestamp","Date","now","cleanup","query","variables","operationName","selectedOperation","simpleResponseObserver","destroy","_this"],"mappings":"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","debug_id":"b7f4fae2-5c70-5cdf-96ff-ea624d9c089b"}